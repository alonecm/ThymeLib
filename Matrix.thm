/*
引用的库文件：ExCore.thm | ExtendArray.thm
！！使用前请确保安装到Algodoo中！！
*/


//矩阵对象（二维数组）
MatrixObject=(row,col)=>{
	_:=alloc;
	_.initialize:=null;//初始化
	_.rowLength:=null;//获取行数
	_.colLength:=null;//获取列数
	_.getElement:=null;//获取指定元素
	_.getRow:=null;//获取一行
	_.getColumn:=null;//获取一列
	_.setElement:=null;//设定指定位置的元素
	_.getContent:=null;//获取全部内容
	_.expand:=null;//扩大给定的行数和列数
	_.getCut:=null;//获取指定区域
	_.indexInside:=null;//检查索引是否在矩阵内部
	_.swapRow:=null;//交换两行
	_.swapColumn:=null;//交换两列
	_.clone:=null;//克隆矩阵
	_.print_Matrix:=null;//打印矩阵
	_->{
		row_length:=0;//行数
		col_length:=0;//列数
		mat_content:=null;//实际内容
		mat_current:=null;//显示内容
		//初始化
		initialize={
			row_length=row;//行数
			col_length=col;//列数
			//添加行
			mat_content=WritableArrayObject(row_length);
			//添加列
			ExCore.sFor(0,row_length,(i)=>{
				mat_content.setElement(i,WritableArrayObject(col_length));
			});
		};
		rowLength={row_length};//获取行数
		colLength={col_length};//获取列数
		//获取指定元素
		getElement=(row_Index,col_Index)=>{
			indexInside(row_Index,col_Index)?{
				(mat_content.getElement(row_Index)).getElement(col_Index)
			}:{print("索引不在矩阵内，获取元素失败！")};
		};
		//获取一行
		getRow=(row_Index)=>{
			row_Index>=0&&row_Index<row_length?{
				mat_content.getElement(row_Index);
			}:{print("行索引不在矩阵内，获取行失败！");WritableArrayObject(0)};
		};
		//获取一列
		getColumn=(col_Index)=>{
			col_Index>=0&&col_Index<col_length?{
				n_arr:=WritableArrayObject(col_length);
				ExCore.sFor(0,col_length,(i)=>{
					n_arr.setElement(i,getElement(i,col_Index));
				});
				n_arr;
			}:{print("列索引不在矩阵内，获取行失败！");WritableArrayObject(0)};
		};
		//设定指定位置的元素
		setElement=(row_Index,col_Index,new_element)=>{
			indexInside(row_Index,col_Index)?{
				mat_current=null;
				(mat_content.getElement(row_Index)).setElement(col_Index,new_element);
			}:{print("索引不在矩阵内，设定元素失败！")};
		};
		//获取全部内容
		getContent={
			mat_current==null?{
				n_arr:=[];
				ExCore.sFor(0,row_length,(i)=>{
					n_arr=n_arr++[(mat_content.getElement(i)).getContent]
				});
				mat_current=n_arr;
			}:{};
			mat_current;
		};
		//扩大给定的行数和列数
		expand=(expand_row_size,expand_col_size)=>{
			expand_row_size>=0?{
				expand_col_size>=0?{
					mat_current=null;
					lastRow:=row_length;
					row_length=row_length+expand_row_size;
					//优先扩大行
					mat_content.expand(expand_row_size);
					ExCore.sFor(lastRow,row_length,(i)=>{
						mat_content.setElement(i,WritableArrayObject(col_length))
					});
					//统一扩大列
					ExCore.sFor(0,row_length,(i)=>{
						(mat_content.getElement(i)).expand(expand_col_size);
					});
					col_length=col_length+expand_col_size;
				}:{print("扩大的列数不能为负！")};
			}:{print("扩大的行数不能为负！")};
		};
		//获取指定区域
		getCut=(row_Index_start,col_Index_start,row_len,col_len)=>{
			n_arr:=MatrixObject(0,0);
			indexInside(row_Index_start,col_Index_start)?{
				row_Index_end:=row_Index_start+row_len;
				col_Index_end:=col_Index_start+col_len;
				row_Index_end>rowLength?{row_Index_end=rowLength}:{};
				col_Index_end>colLength?{col_Index_end=colLength}:{};
				n_arr.expand(row_Index_end-row_Index_start,col_Index_end-col_Index_start);
				ExCore.sFor(row_Index_start,row_Index_end,(r)=>{
					ExCore.sFor(col_Index_start,col_Index_end,(c)=>{
						n_arr.setElement(r-row_Index_start,c-col_Index_start,getElement(r,c));
					});
				});
			}:{print("起始点不在矩阵内！")};
			n_arr
		};
		//检查索引是否在矩阵内部
		indexInside=(row_Index,col_Index)=>{
			row_Index>=0&&row_Index<row_length?{
				col_Index>=0&&col_Index<col_length?{
					true;
				}:{false};
			}:{false};
		};
		//交换两行
		swapRow=(r1,r2)=>{
			mat_content.swap(r1,r2);
		};
		//交换两列
		swapColumn=(c1,c2)=>{
			ExCore.sFor(0,row_length,(r)=>{
				(mat_content.getElement(r)).swap(c1,c2);
			});
		};
		//克隆矩阵
		clone={
			n_mat:=MatrixObject(row_length,col_length);
			ExCore.sFor(0,row_length,(r)=>{
				ExCore.sFor(0,col_length,(c)=>{
					n_mat.setElement(r,c,getElement(r,c));
				});
			});
			n_mat;
		};
		//打印矩阵
		print_Matrix={
			str:="\n";
			ExCore.sFor(0,row_length,(r)=>{
				str=str+"| ";
				ExCore.sFor(0,col_length,(c)=>{
					str=str+getElement(r,c)+" ";
				});
				str=str+"|\n";
			});
			print(str);
		};
	};
	_.initialize;
	_;
};


//矩阵操作
MatrixOperations={
	_:=alloc;
	_.add:=null;//矩阵相加
	_.subtract:=null;//矩阵相减
	_.transpose:=null;//矩阵转置
	_.multiply:=null;//矩阵相乘
	_.inverse:=null;//矩阵求逆
	_.LUDecompose:=null;//矩阵LU分解
	_->{
		//矩阵相加
		add=(matrix1,matrix2)=>{
			matrix1.rowLength==matrix2.rowLength&&matrix1.colLength==matrix2.colLength?{
				n_mat:=MatrixObject(matrix1.rowLength,matrix1.colLength);
				ExCore.sFor(0,matrix1.rowLength,(r)=>{
					ExCore.sFor(0,matrix1.colLength,(c)=>{
						n_mat.setElement(r,c,matrix1.getElement(r,c)+matrix2.getElement(r,c));
					});
				});
				n_mat;
			}:{print("两矩阵大小不一致，无法计算！")};
		};
		//矩阵相减
		subtract=(matrix1,matrix2)=>{
			matrix1.rowLength==matrix2.rowLength&&matrix1.colLength==matrix2.colLength?{
				n_mat:=MatrixObject(matrix1.rowLength,matrix1.colLength);
				ExCore.sFor(0,matrix1.rowLength,(r)=>{
					ExCore.sFor(0,matrix1.colLength,(c)=>{
						n_mat.setElement(r,c,matrix1.getElement(r,c)-matrix2.getElement(r,c));
					});
				});
				n_mat;
			}:{print("两矩阵大小不一致，无法计算！")};
		};
		//矩阵转置
		transpose=(mat)=>{
			n_mat:=MatrixObject(mat.colLength,mat.rowLength);
			ExCore.sFor(0,n_mat.rowLength,(r)=>{
				ExCore.sFor(0,n_mat.colLength,(c)=>{
					n_mat.setElement(r,c,mat.getElement(c,r));
				});
			});
			n_mat
		};
		//矩阵相乘
		multiply=(matrix1,matrix2)=>{
			matrix1.colLength==matrix2.rowLength?{
				n_mat:=MatrixObject(matrix1.rowLength,matrix2.colLength);
				ExCore.sFor(0,n_mat.rowLength,(r)=>{
					ExCore.sFor(0,n_mat.colLength,(c)=>{
						sum:=0;
						ExCore.sFor(0,matrix1.colLength,(k)=>{
							sum=sum+matrix1.getElement(r,k)*matrix2.getElement(k,c);
						});
						n_mat.setElement(r,c,sum);
					});
				});
				n_mat;
			}:{print("两矩阵大小不一致，无法计算！")};
		};
		//矩阵求逆
		inverse=(mat)=>{
			LU_mat:=LUDecompose(mat);

			MatrixOperations.multiply(U,L);
		};
		//L矩阵求逆
		InverseLowerTriangular(Lmat)=>{
			r:=Lmat.rowLength;
			L:=MatrixObject(Lmat.rowLength,Lmat.colLength);
			ExCore.sFor(0,r,(i)=>{
				ExCore.wFor(0,i,(j)=>{
					
				});
			});
		};
		//U矩阵求逆
		InverseUpperTriangular(Lmat)=>{
			rl:=Lmat.rowLength;
			L:=MatrixObject(Lmat.rowLength,Lmat.colLength);
			ExCore.sFor(0,L.rowLength,(i)=>{
				ExCore.wFor(0,i,(j)=>{
					
				});
			});
		};
		//矩阵LU分解
		LUDecompose=(mat)=>{
			U:=mat.clone;
			L:=BasicMatrix.identity(mat.rowLength);
			ExCore.sFor(1,U.rowLength,(round)=>{//轮次循环
				ExCore.sFor(round,U.rowLength,(r)=>{
					den:=U.getElement(round-1,round-1);
					den!=0?{
						first:=U.getElement(r,round-1)/math.tofloat(den);//获取起始计算值
						L.setElement(r,round-1,first);
						ExCore.sFor(round-1,U.colLength,(c)=>{
							U.setElement(r,c,U.getElement(r,c)-first*U.getElement(round-1,c));
						});
					}:{U.swapRow(round-1,round)};//零元素行要交换
					
				});
			});
			[L,U];
		};
	};
	_
};
MatrixOperations=MatrixOperations;

//基本矩阵
BasicMatrix={
	_:=alloc;
	_.zero:=null;//全零矩阵
	_.all_ones:=null;//全一矩阵
	_.identity:=null;//单位矩阵
	_->{
		//全零矩阵
		zero=(row,col)=>{
			n_mat:=MatrixObject(row,col);
			ExCore.sFor(0,row,(i)=>{
				ExCore.sFor(0,col,(j)=>{
					n_mat.setElement(i,j,0);
				});
			});
			n_mat;
		};
		//全一矩阵
		all_ones=(row,col)=>{
			n_mat:=MatrixObject(row,col);
			ExCore.sFor(0,row,(i)=>{
				ExCore.sFor(0,col,(j)=>{
					n_mat.setElement(i,j,1);
				});
			});
			n_mat;
		};
		//单位矩阵
		identity=(dim)=>{
			n_mat:=MatrixObject(dim,dim);
			ExCore.sFor(0,dim,(r)=>{
				ExCore.sFor(0,dim,(c)=>{
					r==c?{n_mat.setElement(r,c,1)}:{n_mat.setElement(r,c,0)};
				});
			});
			n_mat;
		};
	};
	_
};
BasicMatrix=BasicMatrix;